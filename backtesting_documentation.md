# Backtesting Engine Documentation

This document provides a comprehensive guide to using the backtesting engine, detailing its architecture, core components, and how to set up and run backtests.

## 1. Overview

The backtesting engine is an event-driven simulation framework designed to test quantitative trading strategies on historical data. It mimics real-world trading by processing market data, generating trading signals, executing orders, and tracking portfolio performance. Its modular design allows for flexible customization of data sources, strategies, execution logic, and portfolio management.

## 2. Core Components

The engine is built around several interconnected components, each responsible for a specific aspect of the backtesting process:

### 2.1. `EventBus` (`event_bus.py`)

The `EventBus` acts as the central communication hub for all components. It's a queue-based system that passes `Event` objects between different parts of the engine. This decoupled architecture ensures flexibility and scalability.

### 2.2. `Events` (`events.py`)

Events are the messages passed through the `EventBus`. Key event types include:

-   **`MarketEvent`**: Signifies the arrival of new market data (e.g., a new bar).
-   **`SignalEvent`**: Generated by a `Strategy` to indicate a trading opportunity (e.g., BUY, SELL, EXIT).
-   **`OrderEvent`**: Generated by the `Portfolio` in response to a `SignalEvent`, representing an order to be placed (e.g., Market, Limit, Stop).
-   **`FillEvent`**: Generated by the `ExecutionHandler` when an `OrderEvent` is executed in the simulated market.
-   **`CancelOrderEvent`**: Generated to cancel an existing order.

### 2.3. `DataHandler` (`data_handler.py`)

The `DataHandler` is responsible for providing historical market data to the engine.

-   **`CSVDataHandler`**: An implementation that reads historical data from CSV files. It supports filtering by date range, number of bars from the end, and resampling to different timeframes.

**Key Methods:**

-   `update_bars()`: Pushes the next market bar to the `EventBus` as a `MarketEvent`.
-   `get_bars(symbol, N=None, start_date=None, end_date=None)`: Retrieves historical bars for a given symbol.
-   `get_latest_bars(symbol, N=1)`: A convenience method to get the most recent `N` bars.

### 2.4. `Strategy` (`strategy.py`)

A `Strategy` object consumes `MarketEvent`s and generates `SignalEvent`s based on its trading logic.

-   **`Strategy` (Abstract Base Class)**: All custom strategies must inherit from this class and implement the `calculate_signals(self, event)` method.
-   **`BuyAndHoldStrategy`**: A simple example strategy demonstrating various order types and basic signal generation.
-   **`StressTestStrategy`**: Another example strategy designed to test the system with a sequence of diverse order types.

**Key Method:**

-   `calculate_signals(event)`: Contains the core logic to analyze market data and decide when to generate a `SignalEvent`.

### 2.5. `Portfolio` (`portfolio.py`)

The `Portfolio` manages the trading account's cash, positions, and generates `OrderEvent`s in response to `SignalEvent`s. It also tracks individual trades and calculates equity curve.

**Key Responsibilities:**

-   Manages `current_positions` (shares held for each symbol) and `current_holdings` (cash, total equity).
-   `update_timeindex(event)`: Updates portfolio value at each market bar.
-   `update_signal(event)`: Converts `SignalEvent`s into `OrderEvent`s.
-   `update_fill(event)`: Updates positions and holdings based on `FillEvent`s.
-   `_track_trades_from_fill(event)`: Records entry, exit, PnL, and duration of individual trades.
-   `create_equity_curve_dataframe()`: Generates the final equity curve for performance analysis.

### 2.6. `ExecutionHandler` (`execution_handler.py`)

The `ExecutionHandler` simulates the execution of `OrderEvent`s in the market and generates `FillEvent`s.

-   **`SimulatedExecutionHandler`**: Simulates market orders, limit orders, stop orders, stop-limit orders, and trailing stop orders. It can also apply slippage and partial fills.
-   **`CommissionCalculator`**: Base class for calculating trading commissions.
-   **`FixedCommissionCalculator`**: An implementation for fixed rate commissions (e.g., per share with min/max).

**Key Methods:**

-   `execute_order(event)`: Processes `OrderEvent`s and manages open orders.
-   `update(event)`: Checks open orders against current market data to determine fills.
-   `process_immediate_order(order_id, market_event)`: Handles orders that require immediate filling within the same bar.

### 2.7. `PerformanceAnalyzer` (`performance_analyzer.py`)

This component calculates a wide range of performance metrics and generates interactive plots for visualizing backtest results.

**Key Metrics Calculated:**

-   Total Return, Annualized Return, Annualized Volatility, Sharpe Ratio, Max Drawdown, Max Drawdown Duration, Calmar Ratio.
-   Total Trades, Winning/Losing Trades, Winning Percentage, Gross Profit/Loss, Profit Factor, Average Profit/Loss per Trade, Max Consecutive Wins/Losses, Average Trade Duration, Total Commission Paid.

**Plotting Capabilities:**

-   Equity Curve (Matplotlib & Plotly)
-   Drawdown (Matplotlib & Plotly)
-   Trades Overlay on Price Data (Plotly)

### 2.8. `BacktestManager` (`backtest_manager.py`)

Manages the saving and loading of backtest results, including portfolio data, parameters, performance metrics, and plots.

**Key Methods:**

-   `save_backtest(...)`: Saves all relevant data to a uniquely named directory.
-   `load_backtest(backtest_name)`: Loads a previously saved backtest.

## 3. Setting Up and Running a Backtest

To run a backtest, you need to instantiate the `Backtester` class with the appropriate components and parameters, then call its `simulate_trading` method.

### 3.1. `Backtester` Class (`backtester.py`)

**Constructor Parameters:**

-   `csv_dir` (str): Directory containing historical CSV data files.
-   `symbol_list` (List[str]): List of symbols to backtest.
-   `initial_capital` (float): Starting capital for the portfolio.
-   `start_date` (datetime): The date from which the backtest portfolio starts tracking.
-   `heartbeat` (float): Not actively used in the current event loop structure, but can be used for real-time delays.
-   `data_handler` (Class): The `DataHandler` class to use (e.g., `CSVDataHandler`).
-   `execution_handler` (Class): The `ExecutionHandler` class to use (e.g., `SimulatedExecutionHandler`).
-   `portfolio` (Class): The `Portfolio` class to use.
-   `strategy` (Class): The `Strategy` class to use.
-   `strategy_params` (Dict, optional): Dictionary of parameters to pass to the strategy's constructor.
-   `commission_calculator` (CommissionCalculator, optional): An instance of a commission calculator.
-   `start_date_filter` (datetime, optional): Filters historical data to start from this date.
-   `end_date_filter` (datetime, optional): Filters historical data to end at this date.
-   `bars_from_end` (int, optional): Uses only the last `N` bars from the end of the historical data.
-   `resample_interval` (str, optional): Resamples data to a different interval (e.g., '1H', '1D').

### 3.2. Example Usage (`main.py`)

The `main.py` file provides a clear example of how to configure and run a backtest.

```python
import datetime
import logging
from backtester import Backtester
from data_handler import CSVDataHandler
from portfolio import Portfolio
from execution_handler import SimulatedExecutionHandler, FixedCommissionCalculator
from strategies.bollinger_band_strategy import BollingerBandStrategy

if __name__ == "__main__":
    csv_dir = "./data"
    symbol_list = ["EURUSD"]
    initial_capital = 100000.0
    start_date = datetime.datetime(2020, 1, 1)
    heartbeat = 0.0 # Not actively used in current event loop

    strategy_params = {"bb_window": 20, "bb_std_dev": 2}

    commission_calculator = FixedCommissionCalculator(
        rate_per_share=0.0, min_commission=0.0
    )

    backtester = Backtester(
        csv_dir,
        ["EURUSD"],
        initial_capital,
        start_date,
        heartbeat,
        CSVDataHandler,
        SimulatedExecutionHandler,
        Portfolio,
        BollingerBandStrategy,
        strategy_params=strategy_params,
        commission_calculator=commission_calculator,
        bars_from_end=10000,
    )
    backtester.simulate_trading(log_level=logging.INFO)
```

## 4. Customization

### 4.1. Creating Custom Strategies

To create your own trading strategy:

1.  Create a new Python file in the `strategies/` directory (e.g., `my_strategy.py`).
2.  Define a class that inherits from `Strategy` (`from strategy import Strategy`).
3.  Implement the `__init__` method to set up any necessary parameters or state.
4.  Implement the `calculate_signals(self, event)` method. This is where your trading logic resides. Inside this method:
    -   Access market data using `self.data_handler.get_latest_bars()` or `self.data_handler.get_bars()`.
    -   Access portfolio state using `self.portfolio.current_positions` or `self.portfolio.current_holdings`.
    -   Generate `SignalEvent`s using `self.events.put(SignalEvent(...))` when a trading opportunity is identified.

**Example `calculate_signals` snippet:**

```python
# Inside your custom strategy class

def calculate_signals(self, event):
    if event.type == 'MARKET':
        latest_bar = self.data_handler.get_latest_bars(self.symbol, N=1).iloc[-1]
        close_price = latest_bar['close']

        # Example: Simple moving average crossover
        # (You would typically calculate these using the analysis.timeseries module)
        # For demonstration, assume you have SMA_short and SMA_long
        # if SMA_short > SMA_long and not self.bought:
        #     signal = SignalEvent(..., signal_type='LONG', ...)
        #     self.events.put(signal)

        # Example: Buy if price is below a certain threshold
        if close_price < 100 and not self.bought:
            signal = SignalEvent(
                strategy_id=1, 
                symbol=self.symbol, 
                datetime=event.timeindex, 
                signal_type='LONG', 
                strength=1.0,
                sizing_type='FIXED_SHARES', 
                sizing_value=100,
                order_type='MKT'
            )
            self.events.put(signal)
            self.bought = True

        # Example: Exit if price is above a certain threshold
        elif close_price > 110 and self.portfolio.current_positions[self.symbol] > 0:
            signal = SignalEvent(
                strategy_id=1, 
                symbol=self.symbol, 
                datetime=event.timeindex, 
                signal_type='EXIT', 
                strength=1.0,
                sizing_type='FIXED_SHARES', 
                sizing_value=self.portfolio.current_positions[self.symbol],
                order_type='MKT'
            )
            self.events.put(signal)
            self.bought = False
```

### 4.2. Custom Data Handlers, Execution Handlers, and Portfolios

You can create custom implementations by inheriting from their respective base classes (`DataHandler`, `ExecutionHandler`, `Portfolio`) and overriding the necessary methods. This allows you to integrate with different data sources (e.g., databases, live feeds), implement more sophisticated order matching logic, or customize portfolio accounting.

## 5. Output and Results

After `backtester.simulate_trading()` completes, it will:

-   Print a summary of key performance metrics to the console.
-   Save detailed results (equity curve, positions, holdings, closed trades, backtest parameters, performance metrics) to a uniquely timestamped directory within `backtest_results/`.
-   Generate and save various plots (equity curve, drawdown, trades overlay) in both static (PNG) and interactive (HTML) formats within the backtest results directory.

## 6. Integrating with the Analysis Module

The newly developed `analysis` module can be seamlessly integrated with the backtesting engine. For instance:

-   **Data Preparation:** Use `DataManager` to fetch and prepare data before feeding it to the `CSVDataHandler` (e.g., convert API data to CSV format for the backtester).
-   **Strategy Development:** Incorporate functions from `analysis.timeseries` to calculate indicators within your custom strategies. Use `analysis.ml` to generate features, train models, and make predictions that drive your strategy's `SignalEvent`s.

**Example Strategy using Analysis Module:**

```python
# strategies/my_ml_strategy.py

from strategy import Strategy
from events import SignalEvent
from analysis.timeseries import calculate_sma, calculate_rsi
from analysis.ml import create_lagged_features, predict_with_model
import pandas as pd

class MyMLStrategy(Strategy):
    def __init__(self, symbol, events, data_handler, portfolio, execution_handler, ml_model=None):
        super().__init__(symbol, events, data_handler, portfolio, execution_handler)
        self.ml_model = ml_model # Pre-trained ML model
        self.lookback_period = 20 # For features and indicators
        self.bought = False

    def calculate_signals(self, event):
        if event.type == 'MARKET':
            # Get enough historical data for features and indicators
            historical_df = self.data_handler.get_bars(self.symbol, N=self.lookback_period + 1)
            
            if historical_df is not None and len(historical_df) > self.lookback_period:
                # Calculate indicators (using analysis.timeseries)
                historical_df['SMA_10'] = calculate_sma(historical_df, window=10)
                historical_df['RSI_14'] = calculate_rsi(historical_df, window=14)

                # Create features for ML model (using analysis.ml)
                # Ensure features are aligned with the latest bar
                features = create_lagged_features(historical_df, lags=[1, 5], target_column='Close')
                
                # Drop NaNs from indicators and features
                features = features.dropna()
                features = features.join(historical_df[['SMA_10', 'RSI_14']].dropna())

                if not features.empty:
                    latest_features = pd.DataFrame([features.iloc[-1]]) # Get features for the latest bar
                    
                    # Make prediction (using analysis.ml)
                    prediction = predict_with_model(self.ml_model, latest_features).iloc[0]

                    current_position = self.portfolio.current_positions[self.symbol]

                    if prediction == 1 and not self.bought and current_position == 0:
                        # Generate BUY signal
                        signal = SignalEvent(
                            strategy_id=1, 
                            symbol=self.symbol, 
                            datetime=event.timeindex, 
                            signal_type='LONG', 
                            strength=1.0,
                            sizing_type='PERCENT_EQUITY', 
                            sizing_value=0.05, # Invest 5% of equity
                            order_type='MKT'
                        )
                        self.events.put(signal)
                        self.bought = True

                    elif prediction == 0 and self.bought and current_position > 0:
                        # Generate SELL signal (exit position)
                        signal = SignalEvent(
                            strategy_id=1, 
                            symbol=self.symbol, 
                            datetime=event.timeindex, 
                            signal_type='EXIT', 
                            strength=1.0,
                            sizing_type='FIXED_SHARES', 
                            sizing_value=current_position,
                            order_type='MKT'
                        )
                        self.events.put(signal)
                        self.bought = False
```
